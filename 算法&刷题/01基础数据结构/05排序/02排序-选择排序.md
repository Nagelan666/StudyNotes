# 选择排序

#### 1.解决思路

**基本思路：**

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，
与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]
交换，…，第i 次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1 次从arr[n-2]~arr[n-1]中选取最小值，
与arr[n-2]交换，总共通过n-1 次，得到一个按排序码从小到大排列的有序序列。



**具体分析：**

1）在进行选择排序过程中分成有序和无序两个部分，开始都是无序序列

**结果：49、38、65、97、76、13、27、49**

2）从无序序列中取出最小的元素13，将13同无序序列第一个元素交换，此时产生仅含一个元素的有序序列，无序序列减一

**结果：{13、}   {38、65、97、76、49、27、49}**

3）从无序序列中取出最小的元素27，将27同无序序列第一个元素交换，此时产生仅两个元素的有序序列，无序序列减一

**结果：{13、27、}   {65、97、76、49、38、49}**

4）从无序序列中取出最小的元素38，将38同无序序列第一个元素交换，此时产生含三个元素的有序序列，无序序列减一

**结果：{13、27、38、}   {97、76、49、65、49}**

5）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含四个个元素的有序序列，无序序列减一

**结果：{13、27、38、49、}   {76、97、65、49}**

6）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含五个元素的有序序列，无序序列减一

**结果：{13、27、38、49、49、}   {97、65、76}**

7）从无序序列中取出最小的元素65，将65同无序序列第一个元素交换，此时产生含六个元素的有序序列，无序序列减一

**结果：{13、27、38、49、49、65}   {97、76}**

8）从无序序列中取出最小的元素76，将76同无序序列第一个元素交换，此时产生含七个元素的有序序列，无序序列减一

**结果：{13、27、38、49、49、65、76、}   {97}**

9）最后一个元素肯定是最大元素，无序排序直接生产一个有序的序列

**结果：{13、27、38、49、49、65、76、97}**




#### 2.代码

> 代码实现

```java
//选择排序
public static void selectSort(int[] arr) {
    //选择排序时间复杂度是 O(n^2)
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        int min = arr[i];
        for (int j = i + 1; j < arr.length; j++) {
            if (min > arr[j]) { 
                min = arr[j];
                minIndex = j; 
            }
        }

        if (minIndex != i) {
            arr[minIndex] = arr[i];
            arr[i] = min;
        }
    }
}
```

