# [解码方法](https://leetcode-cn.com/problems/decode-ways/)

### 信息卡片

- 时间： 2020-2-9
- 难度：中等
- 题目描述：

```
一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26

给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```



### 参考答案

> 思路

类台阶问题。

如果字符串的第i-2位和第i-1位能组成一个10到26的数字，那么将这两位作为一个数字，剩下还有dp[i-2]种方法

$ dp[i] += dp[i - 2];$

如果字符串的第i-1位不等于0，那么将这一位作为一个数字，剩下还有dp[i-1]种方法

$ dp[i] += dp[i - 1];$



**注意:**

如果出现无法被两位数接纳的0，则无法解码，我们可以在一开始就判断，并将其初始化为0，这样后面的相加永远都是加0



> 代码

```java
   public int numDecodings(String s) {
        if(s.length() == 0) return s.length();
        int[] dp = new int[s.length() + 1];
        // 初始化第一种解码方式
        dp[0] = 1;
        // 如果第一位是0，则无法解码
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        for(int i = 2; i <= s.length(); i++){
            // 如果字符串i前两个字符可以组成一个10~26的数字，将这两个字符作为一种方法，所以剩下还有加上dp[i-2]种方法
            if(Integer.parseInt(s.substring(i-2, i)) <= 26 && Integer.parseInt(s.substring(i-2, i)) >= 10){
                dp[i] += dp[i - 2];
            }
            // 如果字符串i前一个字母不等于0，那么它本身就可以作为字符，将这一个字符作为一种方法，那么剩下还要加上dp[i - 1]种方法
            if(Integer.parseInt(s.substring(i-1, i)) != 0){
                dp[i] += dp[i - 1];
            }
        }
        return dp[s.length()];
    }
```



> 复杂度分析

时间复杂度 ：$O(n)$
空间复杂度 ：$O(n)$ 


