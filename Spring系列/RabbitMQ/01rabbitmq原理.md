# 1 五种消息类型

### 1.1 基本消息模型

 ![1532762975546](./assets\1532762975546.png)



就是普通的生产者消费模型



> ACK

RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：

- 自动ACK：消息一旦被接收，消费者自动发送ACK
- 手动ACK：消息接收后，不会发送ACK，需要手动调用



> 选择

这需要看消息的重要性：

- 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便
- 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。



### 1.2 work消息模型

![1532765197277](./assets/1532765197277.png)

竞争消费者模式：避免执行资源密集型任务时，一个消息只能被一个消费者获取

> 实现非公平竞争

我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。



### 1.3 订阅模型-Fanout

![1527086284940](./assets\1527086284940.png)

之前介绍的工作队列：每个任务只被传递给一个工作人员。

订阅模式：我们将会传递一个信息给多个消费者。

> 解读

1、1个生产者，多个消费者

2、每一个消费者都有自己的一个队列

3、生产者没有将消息直接发送到队列，而是发送到了交换机

4、每个队列都要绑定到交换机

5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的

```java
Fanout：广播，将消息交给所有绑定到交换机的队列

Direct：定向，把消息交给符合指定routing key 的队列 

Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
```









### 1.4 订阅模型-Direct

有选择性的接收消息,在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key），消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。

![1532766437787](./assets\1532766437787.png)



P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。

X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列

C1：消费者，其所在队列指定了需要routing key 为 error 的消息

C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息



### 1.5 订阅模型-Topic

opic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！



> 持久化

交换机还可以通过参数设置持久化



# 2 原理

MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以管道的方式进行传递。

优点：实现了微服务间的高度解耦



> 重要组成部分

**ConnectionFactory（连接管理器）：**应用程序与Rabbit之间建立连接的管理器，程序代码中使用；

**Channel（信道）：**消息推送使用的通道；

**Exchange（交换器）：**基于消息生产者和路由规则可以将消息投递到指定的 Message Queue； 

**Queue（队列）**：用于存储生产者的消息，同时将消息转发给消费者； 

**RoutingKey（路由键）**：用于把生成者的数据分配到交换器上；

**BindingKey（绑定键）**：用于把交换器的消息绑定到队列上；





>实现

RabbitMQ基于AMQP实现，AMQP是一个高级消息队列网络协议，AMQP的工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。 

![](./assets/1.2.png)



你的应用程序和Rabbit  Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。

认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式

![](./assets/1.1.png)



> 为什么不通过TCP直接发送命令

对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，而且操作系统每秒能创建的TCP也是有限的。 



> 持久化工作原理

rabbitMQ默认情况下重启服务器会导致消息丢失，那么怎么保证Rabbit在重启的时候不丢失呢？答案就是消息持久化。

 Rabbit会将你的持久化消息写入磁盘上的持久化日志文件，等消息被消费之后，Rabbit会把这条消息标识为等待垃圾回收。

