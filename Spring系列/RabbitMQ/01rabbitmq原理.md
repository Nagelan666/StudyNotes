# 1 五种消息类型

### 1.1 基本消息模型

 ![1532762975546](./assets\1532762975546.png)



就是普通的生产者消费模型



> ACK

RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：

- 自动ACK：消息一旦被接收，消费者自动发送ACK
- 手动ACK：消息接收后，不会发送ACK，需要手动调用



> 选择

这需要看消息的重要性：

- 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便
- 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。



### 1.2 work消息模型

![1532765197277](./assets/1532765197277.png)

竞争消费者模式：避免执行资源密集型任务时，一个消息只能被一个消费者获取

> 实现非公平竞争

我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。



### 1.3 订阅模型-Fanout

![1527086284940](./assets\1527086284940.png)

之前介绍的工作队列：每个任务只被传递给一个工作人员。

订阅模式：我们将会传递一个信息给多个消费者。

> 解读

1、1个生产者，多个消费者

2、每一个消费者都有自己的一个队列

3、生产者没有将消息直接发送到队列，而是发送到了交换机

4、每个队列都要绑定到交换机

5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的

```java
Fanout：广播，将消息交给所有绑定到交换机的队列

Direct：定向，把消息交给符合指定routing key 的队列 

Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
```









### 1.4 订阅模型-Direct

有选择性的接收消息,在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key），消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。

![1532766437787](./assets\1532766437787.png)



P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。

X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列

C1：消费者，其所在队列指定了需要routing key 为 error 的消息

C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息



### 1.5 订阅模型-Topic

opic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！



> 持久化

交换机还可以通过参数设置持久化



# 2 原理

MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以管道的方式进行传递。

优点：实现了微服务间的高度解耦



你的应用程序和Rabbit  Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。



##### 为什么不通过TCP直接发送命令？

对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，而且操作系统每秒能创建的TCP也是有限的。 



![](./assets/1.1.png)







### 