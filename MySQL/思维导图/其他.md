1 explain

explain模拟优化器执行SQL语句，在5.6以及以后的版本中，除过select，其他比如insert，update和delete均可以使用explain查看执行计划，从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈。  

| 信息          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 查询的序号,id值越大，优先级越高，越先执行                    |
| select_type   | 将select查询分为简单(simple)和复杂两种类型<br />复杂类型又分为子查询(subquery)和from列表中包含子查询(drived) <br />1.simple: 简单的select查询，查询中不包含子查询或者UNION <br />2. primary :查询中若包含任何复杂的子部分，最外层查询被标记 <br />3. subquery:在select或where列表中包含了子查询 <br />4. derived:在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中 <br />5. union:如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from  子句的子查询中，外层select被标记为derived <br />6. union result:UNION 的结果 |
| table         | 输出的行所引用的表                                           |
| type          | 1.all: 全表扫描 <br />2. index:按索引次序扫描，先读索引，再读实际的行，结果还是全表扫描，主要优点是避免了排序。因为索引是排好的。 <br />3.range： 以范围的形式扫描。（where >） <br />4.ref： 非唯一索引访问 <br />5.eq_ref： 使用唯一索引查找(主键或唯一索引) <br />6.const： 常量查询 <br />7.system： 系统查询 <br />8.null: 优化过程中就已经得到结果，不在访问表或索引 |
| possible_keys | 可能用到的索引                                               |
| key           | 实际使用的索引                                               |
| key_len       | 索引字段最大可能使用长度                                     |
| ref           | 显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值 |
| rows          | 估计需要扫描的行数                                           |
| Extra         | 显示以上信息之外的其他信息                                   |